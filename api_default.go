/*
Kalshi API.

This documentation describes Kalshi's REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kalshiAPI

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


type DefaultApi interface {

	/*
	GetEventsCached GetEventsCached

	End-point for getting data about all events with data that is cached and so slightly lagged.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventsCachedRequest
	*/
	GetEventsCached(ctx context.Context) ApiGetEventsCachedRequest

	// GetEventsCachedExecute executes the request
	//  @return GetEventsResponse
	GetEventsCachedExecute(r ApiGetEventsCachedRequest) (*GetEventsResponse, *http.Response, error)

	/*
	GetSeriesList GetSeriesList

	End-point for getting data about all series

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSeriesListRequest
	*/
	GetSeriesList(ctx context.Context) ApiGetSeriesListRequest

	// GetSeriesListExecute executes the request
	//  @return GetSeriesListResponse
	GetSeriesListExecute(r ApiGetSeriesListRequest) (*GetSeriesListResponse, *http.Response, error)

	/*
	GetSeriesListCached GetSeriesListCached

	End-point for getting data about all series. Endpoint is cached so it is slightly lagged.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSeriesListCachedRequest
	*/
	GetSeriesListCached(ctx context.Context) ApiGetSeriesListCachedRequest

	// GetSeriesListCachedExecute executes the request
	//  @return GetSeriesListResponse
	GetSeriesListCachedExecute(r ApiGetSeriesListCachedRequest) (*GetSeriesListResponse, *http.Response, error)

	/*
	GetTrades GetTrades

	End-point for getting all trades for all markets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTradesRequest
	*/
	GetTrades(ctx context.Context) ApiGetTradesRequest

	// GetTradesExecute executes the request
	//  @return TradesGetResponse
	GetTradesExecute(r ApiGetTradesRequest) (*TradesGetResponse, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiGetEventsCachedRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiGetEventsCachedRequest) Execute() (*GetEventsResponse, *http.Response, error) {
	return r.ApiService.GetEventsCachedExecute(r)
}

/*
GetEventsCached GetEventsCached

End-point for getting data about all events with data that is cached and so slightly lagged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventsCachedRequest
*/
func (a *DefaultApiService) GetEventsCached(ctx context.Context) ApiGetEventsCachedRequest {
	return ApiGetEventsCachedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEventsResponse
func (a *DefaultApiService) GetEventsCachedExecute(r ApiGetEventsCachedRequest) (*GetEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEventsCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesListRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiGetSeriesListRequest) Execute() (*GetSeriesListResponse, *http.Response, error) {
	return r.ApiService.GetSeriesListExecute(r)
}

/*
GetSeriesList GetSeriesList

End-point for getting data about all series

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeriesListRequest
*/
func (a *DefaultApiService) GetSeriesList(ctx context.Context) ApiGetSeriesListRequest {
	return ApiGetSeriesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSeriesListResponse
func (a *DefaultApiService) GetSeriesListExecute(r ApiGetSeriesListRequest) (*GetSeriesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSeriesListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSeriesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/series/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesListCachedRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiGetSeriesListCachedRequest) Execute() (*GetSeriesListResponse, *http.Response, error) {
	return r.ApiService.GetSeriesListCachedExecute(r)
}

/*
GetSeriesListCached GetSeriesListCached

End-point for getting data about all series. Endpoint is cached so it is slightly lagged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeriesListCachedRequest
*/
func (a *DefaultApiService) GetSeriesListCached(ctx context.Context) ApiGetSeriesListCachedRequest {
	return ApiGetSeriesListCachedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSeriesListResponse
func (a *DefaultApiService) GetSeriesListCachedExecute(r ApiGetSeriesListCachedRequest) (*GetSeriesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSeriesListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSeriesListCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradesRequest struct {
	ctx context.Context
	ApiService DefaultApi
	tradesDate *string
	pageSize *int64
	pageNumber *int64
	marketId *string
}

// Restricts the response to trades during a certain day (give trades_date in ET with format: YYYY-MM-DD). Dates returned will be UTC
func (r ApiGetTradesRequest) TradesDate(tradesDate string) ApiGetTradesRequest {
	r.tradesDate = &tradesDate
	return r
}

// Parameter to specify the number of results per page
func (r ApiGetTradesRequest) PageSize(pageSize int64) ApiGetTradesRequest {
	r.pageSize = &pageSize
	return r
}

// Parameter to specify which page of the results should be retrieved
func (r ApiGetTradesRequest) PageNumber(pageNumber int64) ApiGetTradesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Parameter to specify a specific marketId to get trades from
func (r ApiGetTradesRequest) MarketId(marketId string) ApiGetTradesRequest {
	r.marketId = &marketId
	return r
}

func (r ApiGetTradesRequest) Execute() (*TradesGetResponse, *http.Response, error) {
	return r.ApiService.GetTradesExecute(r)
}

/*
GetTrades GetTrades

End-point for getting all trades for all markets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradesRequest
*/
func (a *DefaultApiService) GetTrades(ctx context.Context) ApiGetTradesRequest {
	return ApiGetTradesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TradesGetResponse
func (a *DefaultApiService) GetTradesExecute(r ApiGetTradesRequest) (*TradesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TradesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tradesDate != nil {
		localVarQueryParams.Add("trades_date", parameterToString(*r.tradesDate, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("page_number", parameterToString(*r.pageNumber, ""))
	}
	if r.marketId != nil {
		localVarQueryParams.Add("market_id", parameterToString(*r.marketId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
