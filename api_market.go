/*
Kalshi API.

This documentation describes Kalshi's REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kalshiAPI

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type MarketApi interface {

	/*
	GetActiveMarkets GetActiveMarkets

	End-point for getting highly active markets on the exchange.
Currently, gets 3 kinds of activity: Markets opening within the time window provided, markets closing within the time
window provided, and markets that have had large price movements or large volumes within the time window provided.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetActiveMarketsRequest
	*/
	GetActiveMarkets(ctx context.Context) ApiGetActiveMarketsRequest

	// GetActiveMarketsExecute executes the request
	//  @return GetActiveMarketsResponse
	GetActiveMarketsExecute(r ApiGetActiveMarketsRequest) (*GetActiveMarketsResponse, *http.Response, error)

	/*
	GetCandlestickMarketHistory GetCandlestickMarketHistory

	End-point for getting open, high, low, close (OHLC) and other data for candlestick plots. See the response body
for full information on what is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetCandlestickMarketHistoryRequest
	*/
	GetCandlestickMarketHistory(ctx context.Context, marketId string) ApiGetCandlestickMarketHistoryRequest

	// GetCandlestickMarketHistoryExecute executes the request
	//  @return GetCandlestickMarketHistoryResponse
	GetCandlestickMarketHistoryExecute(r ApiGetCandlestickMarketHistoryRequest) (*GetCandlestickMarketHistoryResponse, *http.Response, error)

	/*
	GetCandlestickMarketHistoryCached GetCandlestickMarketHistoryCached

	End-point for getting open, high, low, close (OHLC) and other data for candlestick plots. See the response body
for full information on what is returned. Data is cached and so is slightly lagged.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetCandlestickMarketHistoryCachedRequest
	*/
	GetCandlestickMarketHistoryCached(ctx context.Context, marketId string) ApiGetCandlestickMarketHistoryCachedRequest

	// GetCandlestickMarketHistoryCachedExecute executes the request
	//  @return GetCandlestickMarketHistoryResponse
	GetCandlestickMarketHistoryCachedExecute(r ApiGetCandlestickMarketHistoryCachedRequest) (*GetCandlestickMarketHistoryResponse, *http.Response, error)

	/*
	GetMarket GetMarket

	End-point for getting data about a specific market.

The value for the market_id path parameter should match the id value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketRequest
	*/
	GetMarket(ctx context.Context, marketId string) ApiGetMarketRequest

	// GetMarketExecute executes the request
	//  @return UserGetMarketResponse
	GetMarketExecute(r ApiGetMarketRequest) (*UserGetMarketResponse, *http.Response, error)

	/*
	GetMarketByTicker GetMarketByTicker

	End-point for getting data about a specific market based on its ticker.

The value for the ticker_name path parameter should match the ticker_name value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tickerName Should be filled with the ticker name of the target market
	@return ApiGetMarketByTickerRequest
	*/
	GetMarketByTicker(ctx context.Context, tickerName string) ApiGetMarketByTickerRequest

	// GetMarketByTickerExecute executes the request
	//  @return UserGetMarketResponse
	GetMarketByTickerExecute(r ApiGetMarketByTickerRequest) (*UserGetMarketResponse, *http.Response, error)

	/*
	GetMarketByTickerCached GetMarketByTickerCached

	End-point for getting data about a specific market with data that is cached and so slightly lagged.

The value for the ticker_name path parameter should match the ticker_name value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tickerName Should be filled with the ticker name of the target market
	@return ApiGetMarketByTickerCachedRequest
	*/
	GetMarketByTickerCached(ctx context.Context, tickerName string) ApiGetMarketByTickerCachedRequest

	// GetMarketByTickerCachedExecute executes the request
	//  @return UserGetMarketResponse
	GetMarketByTickerCachedExecute(r ApiGetMarketByTickerCachedRequest) (*UserGetMarketResponse, *http.Response, error)

	/*
	GetMarketCached GetMarketCached

	End-point for getting data about a specific market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketCachedRequest
	*/
	GetMarketCached(ctx context.Context, marketId string) ApiGetMarketCachedRequest

	// GetMarketCachedExecute executes the request
	//  @return UserGetMarketResponse
	GetMarketCachedExecute(r ApiGetMarketCachedRequest) (*UserGetMarketResponse, *http.Response, error)

	/*
	GetMarketHistory GetMarketHistory

	End-point for getting the statistics history for a market.

The value for the market_id path parameter should match the id value of the target market.
The last_seen_ts parameter is optional, and will restrict statistics to those after provided timestamp.
The last_seen_ts is inclusive, which means a market history point at last_seen_ts will be returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketHistoryRequest
	*/
	GetMarketHistory(ctx context.Context, marketId string) ApiGetMarketHistoryRequest

	// GetMarketHistoryExecute executes the request
	//  @return GetMarketHistoryResponse
	GetMarketHistoryExecute(r ApiGetMarketHistoryRequest) (*GetMarketHistoryResponse, *http.Response, error)

	/*
	GetMarketHistoryCached GetMarketHistoryCached

	End-point for getting the statistics history for a market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.
The last_seen_ts parameter is optional, and will restrict statistics to those after provided timestamp.
The last_seen_ts is inclusive, which means a market history point at last_seen_ts will be returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketHistoryCachedRequest
	*/
	GetMarketHistoryCached(ctx context.Context, marketId string) ApiGetMarketHistoryCachedRequest

	// GetMarketHistoryCachedExecute executes the request
	//  @return GetMarketHistoryResponse
	GetMarketHistoryCachedExecute(r ApiGetMarketHistoryCachedRequest) (*GetMarketHistoryResponse, *http.Response, error)

	/*
	GetMarketOrderBook GetMarketOrderBook

	End-point for getting the orderbook for a market.

The value for the market_id path parameter should match the id value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketOrderBookRequest
	*/
	GetMarketOrderBook(ctx context.Context, marketId string) ApiGetMarketOrderBookRequest

	// GetMarketOrderBookExecute executes the request
	//  @return GetMarketOrderBookResponse
	GetMarketOrderBookExecute(r ApiGetMarketOrderBookRequest) (*GetMarketOrderBookResponse, *http.Response, error)

	/*
	GetMarketOrderBookCached GetMarketOrderBookCached

	End-point for getting the orderbook for a market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketId Should be filled with the id of the target market
	@return ApiGetMarketOrderBookCachedRequest
	*/
	GetMarketOrderBookCached(ctx context.Context, marketId string) ApiGetMarketOrderBookCachedRequest

	// GetMarketOrderBookCachedExecute executes the request
	//  @return GetMarketOrderBookResponse
	GetMarketOrderBookCachedExecute(r ApiGetMarketOrderBookCachedRequest) (*GetMarketOrderBookResponse, *http.Response, error)

	/*
	GetMarkets GetMarkets

	End-point for listing / discovering markets on Kalshi.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMarketsRequest
	*/
	GetMarkets(ctx context.Context) ApiGetMarketsRequest

	// GetMarketsExecute executes the request
	//  @return UserGetMarketsResponse
	GetMarketsExecute(r ApiGetMarketsRequest) (*UserGetMarketsResponse, *http.Response, error)

	/*
	GetMarketsCached GetMarketsCached

	End-point for listing / discovering markets on Kalshi with data that is cached and so slightly lagged.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMarketsCachedRequest
	*/
	GetMarketsCached(ctx context.Context) ApiGetMarketsCachedRequest

	// GetMarketsCachedExecute executes the request
	//  @return UserGetMarketsResponse
	GetMarketsCachedExecute(r ApiGetMarketsCachedRequest) (*UserGetMarketsResponse, *http.Response, error)
}

// MarketApiService MarketApi service
type MarketApiService service

type ApiGetActiveMarketsRequest struct {
	ctx context.Context
	ApiService MarketApi
	limit *int64
	minDate *int64
	maxDate *int64
}

// The maximum number of markets returned, this is capped at 20
func (r ApiGetActiveMarketsRequest) Limit(limit int64) ApiGetActiveMarketsRequest {
	r.limit = &limit
	return r
}

// The lower bound on the date searched through when looking for activity
func (r ApiGetActiveMarketsRequest) MinDate(minDate int64) ApiGetActiveMarketsRequest {
	r.minDate = &minDate
	return r
}

// The upper bound on the date searched through when looking for activity
func (r ApiGetActiveMarketsRequest) MaxDate(maxDate int64) ApiGetActiveMarketsRequest {
	r.maxDate = &maxDate
	return r
}

func (r ApiGetActiveMarketsRequest) Execute() (*GetActiveMarketsResponse, *http.Response, error) {
	return r.ApiService.GetActiveMarketsExecute(r)
}

/*
GetActiveMarkets GetActiveMarkets

End-point for getting highly active markets on the exchange.
Currently, gets 3 kinds of activity: Markets opening within the time window provided, markets closing within the time
window provided, and markets that have had large price movements or large volumes within the time window provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveMarketsRequest
*/
func (a *MarketApiService) GetActiveMarkets(ctx context.Context) ApiGetActiveMarketsRequest {
	return ApiGetActiveMarketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetActiveMarketsResponse
func (a *MarketApiService) GetActiveMarketsExecute(r ApiGetActiveMarketsRequest) (*GetActiveMarketsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetActiveMarketsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetActiveMarkets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active_markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.minDate != nil {
		localVarQueryParams.Add("min_date", parameterToString(*r.minDate, ""))
	}
	if r.maxDate != nil {
		localVarQueryParams.Add("max_date", parameterToString(*r.maxDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCandlestickMarketHistoryRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
	lastSeenTs *int64
	numBuckets *int32
}

// If provided, restricts history to trades starting from lastSeenTs
func (r ApiGetCandlestickMarketHistoryRequest) LastSeenTs(lastSeenTs int64) ApiGetCandlestickMarketHistoryRequest {
	r.lastSeenTs = &lastSeenTs
	return r
}

// If provided, this field represents the number of buckets used to divide the market history data. Please provide an integer between 1 and 7,200 (inclusive). Defaults to 1,400. We aggregate data in the buckets.
func (r ApiGetCandlestickMarketHistoryRequest) NumBuckets(numBuckets int32) ApiGetCandlestickMarketHistoryRequest {
	r.numBuckets = &numBuckets
	return r
}

func (r ApiGetCandlestickMarketHistoryRequest) Execute() (*GetCandlestickMarketHistoryResponse, *http.Response, error) {
	return r.ApiService.GetCandlestickMarketHistoryExecute(r)
}

/*
GetCandlestickMarketHistory GetCandlestickMarketHistory

End-point for getting open, high, low, close (OHLC) and other data for candlestick plots. See the response body
for full information on what is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetCandlestickMarketHistoryRequest
*/
func (a *MarketApiService) GetCandlestickMarketHistory(ctx context.Context, marketId string) ApiGetCandlestickMarketHistoryRequest {
	return ApiGetCandlestickMarketHistoryRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetCandlestickMarketHistoryResponse
func (a *MarketApiService) GetCandlestickMarketHistoryExecute(r ApiGetCandlestickMarketHistoryRequest) (*GetCandlestickMarketHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCandlestickMarketHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetCandlestickMarketHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{market_id}/candlestick"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastSeenTs != nil {
		localVarQueryParams.Add("last_seen_ts", parameterToString(*r.lastSeenTs, ""))
	}
	if r.numBuckets != nil {
		localVarQueryParams.Add("num_buckets", parameterToString(*r.numBuckets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCandlestickMarketHistoryCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
	lastSeenTs *int64
	numBuckets *int32
}

// If provided, restricts history to trades starting from lastSeenTs
func (r ApiGetCandlestickMarketHistoryCachedRequest) LastSeenTs(lastSeenTs int64) ApiGetCandlestickMarketHistoryCachedRequest {
	r.lastSeenTs = &lastSeenTs
	return r
}

// If provided, this field represents the number of buckets used to divide the market history data. Please provide an integer between 1 and 7,200 (inclusive). Defaults to 1,400. We aggregate data in the buckets.
func (r ApiGetCandlestickMarketHistoryCachedRequest) NumBuckets(numBuckets int32) ApiGetCandlestickMarketHistoryCachedRequest {
	r.numBuckets = &numBuckets
	return r
}

func (r ApiGetCandlestickMarketHistoryCachedRequest) Execute() (*GetCandlestickMarketHistoryResponse, *http.Response, error) {
	return r.ApiService.GetCandlestickMarketHistoryCachedExecute(r)
}

/*
GetCandlestickMarketHistoryCached GetCandlestickMarketHistoryCached

End-point for getting open, high, low, close (OHLC) and other data for candlestick plots. See the response body
for full information on what is returned. Data is cached and so is slightly lagged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetCandlestickMarketHistoryCachedRequest
*/
func (a *MarketApiService) GetCandlestickMarketHistoryCached(ctx context.Context, marketId string) ApiGetCandlestickMarketHistoryCachedRequest {
	return ApiGetCandlestickMarketHistoryCachedRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetCandlestickMarketHistoryResponse
func (a *MarketApiService) GetCandlestickMarketHistoryCachedExecute(r ApiGetCandlestickMarketHistoryCachedRequest) (*GetCandlestickMarketHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCandlestickMarketHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetCandlestickMarketHistoryCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets/{market_id}/candlestick"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastSeenTs != nil {
		localVarQueryParams.Add("last_seen_ts", parameterToString(*r.lastSeenTs, ""))
	}
	if r.numBuckets != nil {
		localVarQueryParams.Add("num_buckets", parameterToString(*r.numBuckets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
}

func (r ApiGetMarketRequest) Execute() (*UserGetMarketResponse, *http.Response, error) {
	return r.ApiService.GetMarketExecute(r)
}

/*
GetMarket GetMarket

End-point for getting data about a specific market.

The value for the market_id path parameter should match the id value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketRequest
*/
func (a *MarketApiService) GetMarket(ctx context.Context, marketId string) ApiGetMarketRequest {
	return ApiGetMarketRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return UserGetMarketResponse
func (a *MarketApiService) GetMarketExecute(r ApiGetMarketRequest) (*UserGetMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{market_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketByTickerRequest struct {
	ctx context.Context
	ApiService MarketApi
	tickerName string
}

func (r ApiGetMarketByTickerRequest) Execute() (*UserGetMarketResponse, *http.Response, error) {
	return r.ApiService.GetMarketByTickerExecute(r)
}

/*
GetMarketByTicker GetMarketByTicker

End-point for getting data about a specific market based on its ticker.

The value for the ticker_name path parameter should match the ticker_name value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tickerName Should be filled with the ticker name of the target market
 @return ApiGetMarketByTickerRequest
*/
func (a *MarketApiService) GetMarketByTicker(ctx context.Context, tickerName string) ApiGetMarketByTickerRequest {
	return ApiGetMarketByTickerRequest{
		ApiService: a,
		ctx: ctx,
		tickerName: tickerName,
	}
}

// Execute executes the request
//  @return UserGetMarketResponse
func (a *MarketApiService) GetMarketByTickerExecute(r ApiGetMarketByTickerRequest) (*UserGetMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketByTicker")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets_by_ticker/{ticker_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"ticker_name"+"}", url.PathEscape(parameterToString(r.tickerName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketByTickerCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
	tickerName string
}

func (r ApiGetMarketByTickerCachedRequest) Execute() (*UserGetMarketResponse, *http.Response, error) {
	return r.ApiService.GetMarketByTickerCachedExecute(r)
}

/*
GetMarketByTickerCached GetMarketByTickerCached

End-point for getting data about a specific market with data that is cached and so slightly lagged.

The value for the ticker_name path parameter should match the ticker_name value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tickerName Should be filled with the ticker name of the target market
 @return ApiGetMarketByTickerCachedRequest
*/
func (a *MarketApiService) GetMarketByTickerCached(ctx context.Context, tickerName string) ApiGetMarketByTickerCachedRequest {
	return ApiGetMarketByTickerCachedRequest{
		ApiService: a,
		ctx: ctx,
		tickerName: tickerName,
	}
}

// Execute executes the request
//  @return UserGetMarketResponse
func (a *MarketApiService) GetMarketByTickerCachedExecute(r ApiGetMarketByTickerCachedRequest) (*UserGetMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketByTickerCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets_by_ticker/{ticker_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"ticker_name"+"}", url.PathEscape(parameterToString(r.tickerName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
}

func (r ApiGetMarketCachedRequest) Execute() (*UserGetMarketResponse, *http.Response, error) {
	return r.ApiService.GetMarketCachedExecute(r)
}

/*
GetMarketCached GetMarketCached

End-point for getting data about a specific market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketCachedRequest
*/
func (a *MarketApiService) GetMarketCached(ctx context.Context, marketId string) ApiGetMarketCachedRequest {
	return ApiGetMarketCachedRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return UserGetMarketResponse
func (a *MarketApiService) GetMarketCachedExecute(r ApiGetMarketCachedRequest) (*UserGetMarketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets/{market_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketHistoryRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
	lastSeenTs *int64
	numBuckets *int32
}

// If provided, restricts history to trades starting from lastSeenTs
func (r ApiGetMarketHistoryRequest) LastSeenTs(lastSeenTs int64) ApiGetMarketHistoryRequest {
	r.lastSeenTs = &lastSeenTs
	return r
}

// If provided, this field represents the number of buckets used to group the market price history data. Please provide an integer between 1 and 7,200 (inclusive). The higher this value, the more points will be returned from this endpoint. Note that the number of points returned may not be equal to the number of buckets because some buckets may not contain any points. Defaults to 1,400. We pick one representative point from each bucket (namely the last point in the bucket)
func (r ApiGetMarketHistoryRequest) NumBuckets(numBuckets int32) ApiGetMarketHistoryRequest {
	r.numBuckets = &numBuckets
	return r
}

func (r ApiGetMarketHistoryRequest) Execute() (*GetMarketHistoryResponse, *http.Response, error) {
	return r.ApiService.GetMarketHistoryExecute(r)
}

/*
GetMarketHistory GetMarketHistory

End-point for getting the statistics history for a market.

The value for the market_id path parameter should match the id value of the target market.
The last_seen_ts parameter is optional, and will restrict statistics to those after provided timestamp.
The last_seen_ts is inclusive, which means a market history point at last_seen_ts will be returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketHistoryRequest
*/
func (a *MarketApiService) GetMarketHistory(ctx context.Context, marketId string) ApiGetMarketHistoryRequest {
	return ApiGetMarketHistoryRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetMarketHistoryResponse
func (a *MarketApiService) GetMarketHistoryExecute(r ApiGetMarketHistoryRequest) (*GetMarketHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{market_id}/stats_history"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastSeenTs != nil {
		localVarQueryParams.Add("last_seen_ts", parameterToString(*r.lastSeenTs, ""))
	}
	if r.numBuckets != nil {
		localVarQueryParams.Add("num_buckets", parameterToString(*r.numBuckets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketHistoryCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
	lastSeenTs *int64
	numBuckets *int32
}

// If provided, restricts history to trades starting from lastSeenTs
func (r ApiGetMarketHistoryCachedRequest) LastSeenTs(lastSeenTs int64) ApiGetMarketHistoryCachedRequest {
	r.lastSeenTs = &lastSeenTs
	return r
}

// If provided, this field represents the number of buckets used to group the market price history data. Please provide an integer between 1 and 7,200 (inclusive). The higher this value, the more points will be returned from this endpoint. Note that the number of points returned may not be equal to the number of buckets because some buckets may not contain any points. Defaults to 1,400. We pick one representative point from each bucket (namely the last point in the bucket)
func (r ApiGetMarketHistoryCachedRequest) NumBuckets(numBuckets int32) ApiGetMarketHistoryCachedRequest {
	r.numBuckets = &numBuckets
	return r
}

func (r ApiGetMarketHistoryCachedRequest) Execute() (*GetMarketHistoryResponse, *http.Response, error) {
	return r.ApiService.GetMarketHistoryCachedExecute(r)
}

/*
GetMarketHistoryCached GetMarketHistoryCached

End-point for getting the statistics history for a market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.
The last_seen_ts parameter is optional, and will restrict statistics to those after provided timestamp.
The last_seen_ts is inclusive, which means a market history point at last_seen_ts will be returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketHistoryCachedRequest
*/
func (a *MarketApiService) GetMarketHistoryCached(ctx context.Context, marketId string) ApiGetMarketHistoryCachedRequest {
	return ApiGetMarketHistoryCachedRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetMarketHistoryResponse
func (a *MarketApiService) GetMarketHistoryCachedExecute(r ApiGetMarketHistoryCachedRequest) (*GetMarketHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketHistoryCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets/{market_id}/stats_history"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastSeenTs != nil {
		localVarQueryParams.Add("last_seen_ts", parameterToString(*r.lastSeenTs, ""))
	}
	if r.numBuckets != nil {
		localVarQueryParams.Add("num_buckets", parameterToString(*r.numBuckets, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketOrderBookRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
}

func (r ApiGetMarketOrderBookRequest) Execute() (*GetMarketOrderBookResponse, *http.Response, error) {
	return r.ApiService.GetMarketOrderBookExecute(r)
}

/*
GetMarketOrderBook GetMarketOrderBook

End-point for getting the orderbook for a market.

The value for the market_id path parameter should match the id value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketOrderBookRequest
*/
func (a *MarketApiService) GetMarketOrderBook(ctx context.Context, marketId string) ApiGetMarketOrderBookRequest {
	return ApiGetMarketOrderBookRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetMarketOrderBookResponse
func (a *MarketApiService) GetMarketOrderBookExecute(r ApiGetMarketOrderBookRequest) (*GetMarketOrderBookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketOrderBookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketOrderBook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/{market_id}/order_book"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketOrderBookCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
	marketId string
}

func (r ApiGetMarketOrderBookCachedRequest) Execute() (*GetMarketOrderBookResponse, *http.Response, error) {
	return r.ApiService.GetMarketOrderBookCachedExecute(r)
}

/*
GetMarketOrderBookCached GetMarketOrderBookCached

End-point for getting the orderbook for a market with data that is cached and so slightly lagged.

The value for the market_id path parameter should match the id value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketId Should be filled with the id of the target market
 @return ApiGetMarketOrderBookCachedRequest
*/
func (a *MarketApiService) GetMarketOrderBookCached(ctx context.Context, marketId string) ApiGetMarketOrderBookCachedRequest {
	return ApiGetMarketOrderBookCachedRequest{
		ApiService: a,
		ctx: ctx,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return GetMarketOrderBookResponse
func (a *MarketApiService) GetMarketOrderBookCachedExecute(r ApiGetMarketOrderBookCachedRequest) (*GetMarketOrderBookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketOrderBookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketOrderBookCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets/{market_id}/order_book"
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsRequest struct {
	ctx context.Context
	ApiService MarketApi
}

func (r ApiGetMarketsRequest) Execute() (*UserGetMarketsResponse, *http.Response, error) {
	return r.ApiService.GetMarketsExecute(r)
}

/*
GetMarkets GetMarkets

End-point for listing / discovering markets on Kalshi.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsRequest
*/
func (a *MarketApiService) GetMarkets(ctx context.Context) ApiGetMarketsRequest {
	return ApiGetMarketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserGetMarketsResponse
func (a *MarketApiService) GetMarketsExecute(r ApiGetMarketsRequest) (*UserGetMarketsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarkets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketsCachedRequest struct {
	ctx context.Context
	ApiService MarketApi
}

func (r ApiGetMarketsCachedRequest) Execute() (*UserGetMarketsResponse, *http.Response, error) {
	return r.ApiService.GetMarketsCachedExecute(r)
}

/*
GetMarketsCached GetMarketsCached

End-point for listing / discovering markets on Kalshi with data that is cached and so slightly lagged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketsCachedRequest
*/
func (a *MarketApiService) GetMarketsCached(ctx context.Context) ApiGetMarketsCachedRequest {
	return ApiGetMarketsCachedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserGetMarketsResponse
func (a *MarketApiService) GetMarketsCachedExecute(r ApiGetMarketsCachedRequest) (*UserGetMarketsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketApiService.GetMarketsCached")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cached/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
