/*
Kalshi API.

This documentation describes Kalshi's REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kalshiAPI

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type UserApi interface {

	/*
	UserAddFavoritedSeries UserAddFavoritedSeries

	End-point for adding a series to the logged in user's favorites.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the series_ticker path parameter should match the ticker value of the series to be added.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId user_id should be filled with your user_id provided on log_in
	@param seriesTicker series_ticker should be filled with the ticker of the series to be added to the list
	@return ApiUserAddFavoritedSeriesRequest
	*/
	UserAddFavoritedSeries(ctx context.Context, userId string, seriesTicker string) ApiUserAddFavoritedSeriesRequest

	// UserAddFavoritedSeriesExecute executes the request
	UserAddFavoritedSeriesExecute(r ApiUserAddFavoritedSeriesRequest) (*http.Response, error)

	/*
	UserAddWatchlist UserAddWatchlist

	End-point for adding a market to the logged in user's watchlist.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the market to be added.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId user_id should be filled with your user_id provided on log_in
	@param marketId market_id should be filled with the id of the market to be added to the watchlist
	@return ApiUserAddWatchlistRequest
	*/
	UserAddWatchlist(ctx context.Context, userId string, marketId string) ApiUserAddWatchlistRequest

	// UserAddWatchlistExecute executes the request
	UserAddWatchlistExecute(r ApiUserAddWatchlistRequest) (*http.Response, error)

	/*
	UserBatchOrdersCancel UserBatchOrdersCancel

	End-point for cancelling multiple orders at once.

Each order in the batch is counted against the total rate limit for order operations.
Consequently, the size of the batch is capped by the current per-second rate-limit
configuration applicable to the user.

At the moment of writing, the limit is 30 orders per batch.
Available to members with advanced access only.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserBatchOrdersCancelRequest
	*/
	UserBatchOrdersCancel(ctx context.Context, userId string) ApiUserBatchOrdersCancelRequest

	// UserBatchOrdersCancelExecute executes the request
	//  @return UserBatchOrdersCancelResponse
	UserBatchOrdersCancelExecute(r ApiUserBatchOrdersCancelRequest) (*UserBatchOrdersCancelResponse, *http.Response, error)

	/*
	UserBatchOrdersCreate UserBatchOrdersCreate

	Endpoint for submitting a batch of orders.

Each order in the batch is counted against the total rate limit for order operations.
Consequently, the size of the batch is capped by the current per-second rate-limit
configuration applicable to the user.

At the moment of writing, the limit is 30 orders per batch.
Available to members with advanced access only.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserBatchOrdersCreateRequest
	*/
	UserBatchOrdersCreate(ctx context.Context, userId string) ApiUserBatchOrdersCreateRequest

	// UserBatchOrdersCreateExecute executes the request
	//  @return UserBatchOrdersCreateResponse
	UserBatchOrdersCreateExecute(r ApiUserBatchOrdersCreateRequest) (*UserBatchOrdersCreateResponse, *http.Response, error)

	/*
	UserChangePassword UserChangePassword

	End-point for updating logged-in user password.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserChangePasswordRequest
	*/
	UserChangePassword(ctx context.Context, userId string) ApiUserChangePasswordRequest

	// UserChangePasswordExecute executes the request
	UserChangePasswordExecute(r ApiUserChangePasswordRequest) (*http.Response, error)

	/*
	UserDeactivate UserDeactivate

	End-point for deactivating an user. A call to this end-point deactivates the current user and ends the current session.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUserDeactivateRequest
	*/
	UserDeactivate(ctx context.Context) ApiUserDeactivateRequest

	// UserDeactivateExecute executes the request
	//  @return CreateUserResponse
	UserDeactivateExecute(r ApiUserDeactivateRequest) (*CreateUserResponse, *http.Response, error)

	/*
	UserGetBalance UserGetBalance

	End-point for getting the balance of the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiUserGetBalanceRequest
	*/
	UserGetBalance(ctx context.Context, userId string) ApiUserGetBalanceRequest

	// UserGetBalanceExecute executes the request
	//  @return UserGetBalanceResponse
	UserGetBalanceExecute(r ApiUserGetBalanceRequest) (*UserGetBalanceResponse, *http.Response, error)

	/*
	UserGetFavoritedSeries UserGetFavoritedSeries

	End-point for getting the favorited series for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId user_id should be filled with your user_id provided on log_in
	@return ApiUserGetFavoritedSeriesRequest
	*/
	UserGetFavoritedSeries(ctx context.Context, userId string) ApiUserGetFavoritedSeriesRequest

	// UserGetFavoritedSeriesExecute executes the request
	//  @return UserGetFavoritedSeriesResponse
	UserGetFavoritedSeriesExecute(r ApiUserGetFavoritedSeriesRequest) (*UserGetFavoritedSeriesResponse, *http.Response, error)

	/*
	UserGetMarketPosition UserGetMarketPosition

	End-point for getting the market positions for the logged in user, in a specific market.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the target market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@param marketId Should be filled with the id of the target market
	@return ApiUserGetMarketPositionRequest
	*/
	UserGetMarketPosition(ctx context.Context, userId string, marketId string) ApiUserGetMarketPositionRequest

	// UserGetMarketPositionExecute executes the request
	//  @return UserGetMarketPositionResponse
	UserGetMarketPositionExecute(r ApiUserGetMarketPositionRequest) (*UserGetMarketPositionResponse, *http.Response, error)

	/*
	UserGetMarketPositions UserGetMarketPositions

	End-point for getting all market positions for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiUserGetMarketPositionsRequest
	*/
	UserGetMarketPositions(ctx context.Context, userId string) ApiUserGetMarketPositionsRequest

	// UserGetMarketPositionsExecute executes the request
	//  @return UserGetMarketPositionsResponse
	UserGetMarketPositionsExecute(r ApiUserGetMarketPositionsRequest) (*UserGetMarketPositionsResponse, *http.Response, error)

	/*
	UserGetProfile UserGetProfile

	End-point for retrieving the logged in user's profile.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiUserGetProfileRequest
	*/
	UserGetProfile(ctx context.Context, userId string) ApiUserGetProfileRequest

	// UserGetProfileExecute executes the request
	//  @return UserGetProfileResponse
	UserGetProfileExecute(r ApiUserGetProfileRequest) (*UserGetProfileResponse, *http.Response, error)

	/*
	UserGetReferralInfo UserGetReferralInfo

	End-point for getting all information related to a member's referral status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiUserGetReferralInfoRequest
	*/
	UserGetReferralInfo(ctx context.Context, userId string) ApiUserGetReferralInfoRequest

	// UserGetReferralInfoExecute executes the request
	//  @return UserGetReferralInfoResponse
	UserGetReferralInfoExecute(r ApiUserGetReferralInfoRequest) (*UserGetReferralInfoResponse, *http.Response, error)

	/*
	UserGetWatchlist UserGetWatchlist

	End-point for getting the market watchlist for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiUserGetWatchlistRequest
	*/
	UserGetWatchlist(ctx context.Context, userId string) ApiUserGetWatchlistRequest

	// UserGetWatchlistExecute executes the request
	//  @return UserGetWatchlistResponse
	UserGetWatchlistExecute(r ApiUserGetWatchlistRequest) (*UserGetWatchlistResponse, *http.Response, error)

	/*
	UserOrderCancel UserOrderCancel

	End-point for canceling orders.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).
The value for the order_id should match the id field of the order you want to decrease.
Commonly delete end-points return 204 status with no body content on success.
But we can't completely delete the order, as it may be partially filled already.
So what the delete end-point does is just reducing the order completely zeroing the remaining resting contracts on it.
The zeroed order is returned on the response payload, as a form of validation for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@param orderId This order_id should be filled with the id of the order to be decrease
	@return ApiUserOrderCancelRequest
	*/
	UserOrderCancel(ctx context.Context, userId string, orderId string) ApiUserOrderCancelRequest

	// UserOrderCancelExecute executes the request
	//  @return UserOrderDecreaseResponse
	UserOrderCancelExecute(r ApiUserOrderCancelRequest) (*UserOrderDecreaseResponse, *http.Response, error)

	/*
	UserOrderCreate UserOrderCreate

	End-point for submitting orders in a market.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserOrderCreateRequest
	*/
	UserOrderCreate(ctx context.Context, userId string) ApiUserOrderCreateRequest

	// UserOrderCreateExecute executes the request
	//  @return UserOrderCreateResponse
	UserOrderCreateExecute(r ApiUserOrderCreateRequest) (*UserOrderCreateResponse, *http.Response, error)

	/*
	UserOrderDecrease UserOrderDecrease

	End-point for decreasing the number of contracts on orders. This is the only kind of edit we support on orders.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the order_id should match the id field of the order you want to decrease.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@param orderId This order_id should be filled with the id of the order to be decrease
	@return ApiUserOrderDecreaseRequest
	*/
	UserOrderDecrease(ctx context.Context, userId string, orderId string) ApiUserOrderDecreaseRequest

	// UserOrderDecreaseExecute executes the request
	//  @return UserOrderDecreaseResponse
	UserOrderDecreaseExecute(r ApiUserOrderDecreaseRequest) (*UserOrderDecreaseResponse, *http.Response, error)

	/*
	UserOrdersGet UserOrdersGet

	End-point for getting all orders for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserOrdersGetRequest
	*/
	UserOrdersGet(ctx context.Context, userId string) ApiUserOrdersGetRequest

	// UserOrdersGetExecute executes the request
	//  @return UserOrdersGetResponse
	UserOrdersGetExecute(r ApiUserOrdersGetRequest) (*UserOrdersGetResponse, *http.Response, error)

	/*
	UserRemoveFavoritedSeries UserRemoveFavoritedSeries

	End-point for removing a series from the logged in user's favorites.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the series_ticker path parameter should match the ticker value of the series to be removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId user_id should be filled with your user_id provided on log_in
	@param seriesTicker series_ticker should be filled with the ticker of the series to be removed from the list
	@return ApiUserRemoveFavoritedSeriesRequest
	*/
	UserRemoveFavoritedSeries(ctx context.Context, userId string, seriesTicker string) ApiUserRemoveFavoritedSeriesRequest

	// UserRemoveFavoritedSeriesExecute executes the request
	UserRemoveFavoritedSeriesExecute(r ApiUserRemoveFavoritedSeriesRequest) (*http.Response, error)

	/*
	UserRemoveWatchlist UserRemoveWatchlist

	End-point for removing a market from the logged in user's watchlist.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the market to be added.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@param marketId Should be filled with the id of the target market
	@return ApiUserRemoveWatchlistRequest
	*/
	UserRemoveWatchlist(ctx context.Context, userId string, marketId string) ApiUserRemoveWatchlistRequest

	// UserRemoveWatchlistExecute executes the request
	UserRemoveWatchlistExecute(r ApiUserRemoveWatchlistRequest) (*http.Response, error)

	/*
	UserTradesGet UserTradesGet

	End-point for getting all trades for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserTradesGetRequest
	*/
	UserTradesGet(ctx context.Context, userId string) ApiUserTradesGetRequest

	// UserTradesGetExecute executes the request
	//  @return UserTradesGetResponse
	UserTradesGetExecute(r ApiUserTradesGetRequest) (*UserTradesGetResponse, *http.Response, error)
}

// UserApiService UserApi service
type UserApiService service

type ApiUserAddFavoritedSeriesRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	seriesTicker string
}

func (r ApiUserAddFavoritedSeriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserAddFavoritedSeriesExecute(r)
}

/*
UserAddFavoritedSeries UserAddFavoritedSeries

End-point for adding a series to the logged in user's favorites.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the series_ticker path parameter should match the ticker value of the series to be added.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId user_id should be filled with your user_id provided on log_in
 @param seriesTicker series_ticker should be filled with the ticker of the series to be added to the list
 @return ApiUserAddFavoritedSeriesRequest
*/
func (a *UserApiService) UserAddFavoritedSeries(ctx context.Context, userId string, seriesTicker string) ApiUserAddFavoritedSeriesRequest {
	return ApiUserAddFavoritedSeriesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		seriesTicker: seriesTicker,
	}
}

// Execute executes the request
func (a *UserApiService) UserAddFavoritedSeriesExecute(r ApiUserAddFavoritedSeriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserAddFavoritedSeries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/favorited_series/{series_ticker}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_ticker"+"}", url.PathEscape(parameterToString(r.seriesTicker, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserAddWatchlistRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	marketId string
}

func (r ApiUserAddWatchlistRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserAddWatchlistExecute(r)
}

/*
UserAddWatchlist UserAddWatchlist

End-point for adding a market to the logged in user's watchlist.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the market to be added.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId user_id should be filled with your user_id provided on log_in
 @param marketId market_id should be filled with the id of the market to be added to the watchlist
 @return ApiUserAddWatchlistRequest
*/
func (a *UserApiService) UserAddWatchlist(ctx context.Context, userId string, marketId string) ApiUserAddWatchlistRequest {
	return ApiUserAddWatchlistRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		marketId: marketId,
	}
}

// Execute executes the request
func (a *UserApiService) UserAddWatchlistExecute(r ApiUserAddWatchlistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserAddWatchlist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/watchlist/{market_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserBatchOrdersCancelRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	userBatchOrdersCancelRequest *UserBatchOrdersCancelRequest
}

// Orders cancel input data
func (r ApiUserBatchOrdersCancelRequest) UserBatchOrdersCancelRequest(userBatchOrdersCancelRequest UserBatchOrdersCancelRequest) ApiUserBatchOrdersCancelRequest {
	r.userBatchOrdersCancelRequest = &userBatchOrdersCancelRequest
	return r
}

func (r ApiUserBatchOrdersCancelRequest) Execute() (*UserBatchOrdersCancelResponse, *http.Response, error) {
	return r.ApiService.UserBatchOrdersCancelExecute(r)
}

/*
UserBatchOrdersCancel UserBatchOrdersCancel

End-point for cancelling multiple orders at once.

Each order in the batch is counted against the total rate limit for order operations.
Consequently, the size of the batch is capped by the current per-second rate-limit
configuration applicable to the user.

At the moment of writing, the limit is 30 orders per batch.
Available to members with advanced access only.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserBatchOrdersCancelRequest
*/
func (a *UserApiService) UserBatchOrdersCancel(ctx context.Context, userId string) ApiUserBatchOrdersCancelRequest {
	return ApiUserBatchOrdersCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserBatchOrdersCancelResponse
func (a *UserApiService) UserBatchOrdersCancelExecute(r ApiUserBatchOrdersCancelRequest) (*UserBatchOrdersCancelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserBatchOrdersCancelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserBatchOrdersCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/batch_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userBatchOrdersCancelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserBatchOrdersCreateRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	userBatchOrdersCreateRequest *UserBatchOrdersCreateRequest
}

// Order create input data
func (r ApiUserBatchOrdersCreateRequest) UserBatchOrdersCreateRequest(userBatchOrdersCreateRequest UserBatchOrdersCreateRequest) ApiUserBatchOrdersCreateRequest {
	r.userBatchOrdersCreateRequest = &userBatchOrdersCreateRequest
	return r
}

func (r ApiUserBatchOrdersCreateRequest) Execute() (*UserBatchOrdersCreateResponse, *http.Response, error) {
	return r.ApiService.UserBatchOrdersCreateExecute(r)
}

/*
UserBatchOrdersCreate UserBatchOrdersCreate

Endpoint for submitting a batch of orders.

Each order in the batch is counted against the total rate limit for order operations.
Consequently, the size of the batch is capped by the current per-second rate-limit
configuration applicable to the user.

At the moment of writing, the limit is 30 orders per batch.
Available to members with advanced access only.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserBatchOrdersCreateRequest
*/
func (a *UserApiService) UserBatchOrdersCreate(ctx context.Context, userId string) ApiUserBatchOrdersCreateRequest {
	return ApiUserBatchOrdersCreateRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserBatchOrdersCreateResponse
func (a *UserApiService) UserBatchOrdersCreateExecute(r ApiUserBatchOrdersCreateRequest) (*UserBatchOrdersCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserBatchOrdersCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserBatchOrdersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/batch_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userBatchOrdersCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserChangePasswordRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	userChangePasswordRequest *UserChangePasswordRequest
}

// Change password input fields.
func (r ApiUserChangePasswordRequest) UserChangePasswordRequest(userChangePasswordRequest UserChangePasswordRequest) ApiUserChangePasswordRequest {
	r.userChangePasswordRequest = &userChangePasswordRequest
	return r
}

func (r ApiUserChangePasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserChangePasswordExecute(r)
}

/*
UserChangePassword UserChangePassword

End-point for updating logged-in user password.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserChangePasswordRequest
*/
func (a *UserApiService) UserChangePassword(ctx context.Context, userId string) ApiUserChangePasswordRequest {
	return ApiUserChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *UserApiService) UserChangePasswordExecute(r ApiUserChangePasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserChangePassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/password"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userChangePasswordRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserDeactivateRequest struct {
	ctx context.Context
	ApiService UserApi
}

func (r ApiUserDeactivateRequest) Execute() (*CreateUserResponse, *http.Response, error) {
	return r.ApiService.UserDeactivateExecute(r)
}

/*
UserDeactivate UserDeactivate

End-point for deactivating an user. A call to this end-point deactivates the current user and ends the current session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserDeactivateRequest
*/
func (a *UserApiService) UserDeactivate(ctx context.Context) ApiUserDeactivateRequest {
	return ApiUserDeactivateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUserResponse
func (a *UserApiService) UserDeactivateExecute(r ApiUserDeactivateRequest) (*CreateUserResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUserResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserDeactivate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetBalanceRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetBalanceRequest) Execute() (*UserGetBalanceResponse, *http.Response, error) {
	return r.ApiService.UserGetBalanceExecute(r)
}

/*
UserGetBalance UserGetBalance

End-point for getting the balance of the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiUserGetBalanceRequest
*/
func (a *UserApiService) UserGetBalance(ctx context.Context, userId string) ApiUserGetBalanceRequest {
	return ApiUserGetBalanceRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetBalanceResponse
func (a *UserApiService) UserGetBalanceExecute(r ApiUserGetBalanceRequest) (*UserGetBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/balance"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetFavoritedSeriesRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetFavoritedSeriesRequest) Execute() (*UserGetFavoritedSeriesResponse, *http.Response, error) {
	return r.ApiService.UserGetFavoritedSeriesExecute(r)
}

/*
UserGetFavoritedSeries UserGetFavoritedSeries

End-point for getting the favorited series for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId user_id should be filled with your user_id provided on log_in
 @return ApiUserGetFavoritedSeriesRequest
*/
func (a *UserApiService) UserGetFavoritedSeries(ctx context.Context, userId string) ApiUserGetFavoritedSeriesRequest {
	return ApiUserGetFavoritedSeriesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetFavoritedSeriesResponse
func (a *UserApiService) UserGetFavoritedSeriesExecute(r ApiUserGetFavoritedSeriesRequest) (*UserGetFavoritedSeriesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetFavoritedSeriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetFavoritedSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/favorited_series"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetMarketPositionRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	marketId string
}

func (r ApiUserGetMarketPositionRequest) Execute() (*UserGetMarketPositionResponse, *http.Response, error) {
	return r.ApiService.UserGetMarketPositionExecute(r)
}

/*
UserGetMarketPosition UserGetMarketPosition

End-point for getting the market positions for the logged in user, in a specific market.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the target market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @param marketId Should be filled with the id of the target market
 @return ApiUserGetMarketPositionRequest
*/
func (a *UserApiService) UserGetMarketPosition(ctx context.Context, userId string, marketId string) ApiUserGetMarketPositionRequest {
	return ApiUserGetMarketPositionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		marketId: marketId,
	}
}

// Execute executes the request
//  @return UserGetMarketPositionResponse
func (a *UserApiService) UserGetMarketPositionExecute(r ApiUserGetMarketPositionRequest) (*UserGetMarketPositionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketPositionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetMarketPosition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/positions/{market_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetMarketPositionsRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetMarketPositionsRequest) Execute() (*UserGetMarketPositionsResponse, *http.Response, error) {
	return r.ApiService.UserGetMarketPositionsExecute(r)
}

/*
UserGetMarketPositions UserGetMarketPositions

End-point for getting all market positions for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiUserGetMarketPositionsRequest
*/
func (a *UserApiService) UserGetMarketPositions(ctx context.Context, userId string) ApiUserGetMarketPositionsRequest {
	return ApiUserGetMarketPositionsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetMarketPositionsResponse
func (a *UserApiService) UserGetMarketPositionsExecute(r ApiUserGetMarketPositionsRequest) (*UserGetMarketPositionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetMarketPositionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetMarketPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/positions"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetProfileRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetProfileRequest) Execute() (*UserGetProfileResponse, *http.Response, error) {
	return r.ApiService.UserGetProfileExecute(r)
}

/*
UserGetProfile UserGetProfile

End-point for retrieving the logged in user's profile.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiUserGetProfileRequest
*/
func (a *UserApiService) UserGetProfile(ctx context.Context, userId string) ApiUserGetProfileRequest {
	return ApiUserGetProfileRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetProfileResponse
func (a *UserApiService) UserGetProfileExecute(r ApiUserGetProfileRequest) (*UserGetProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetReferralInfoRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetReferralInfoRequest) Execute() (*UserGetReferralInfoResponse, *http.Response, error) {
	return r.ApiService.UserGetReferralInfoExecute(r)
}

/*
UserGetReferralInfo UserGetReferralInfo

End-point for getting all information related to a member's referral status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiUserGetReferralInfoRequest
*/
func (a *UserApiService) UserGetReferralInfo(ctx context.Context, userId string) ApiUserGetReferralInfoRequest {
	return ApiUserGetReferralInfoRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetReferralInfoResponse
func (a *UserApiService) UserGetReferralInfoExecute(r ApiUserGetReferralInfoRequest) (*UserGetReferralInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetReferralInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetReferralInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/referrals"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetWatchlistRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
}

func (r ApiUserGetWatchlistRequest) Execute() (*UserGetWatchlistResponse, *http.Response, error) {
	return r.ApiService.UserGetWatchlistExecute(r)
}

/*
UserGetWatchlist UserGetWatchlist

End-point for getting the market watchlist for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiUserGetWatchlistRequest
*/
func (a *UserApiService) UserGetWatchlist(ctx context.Context, userId string) ApiUserGetWatchlistRequest {
	return ApiUserGetWatchlistRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetWatchlistResponse
func (a *UserApiService) UserGetWatchlistExecute(r ApiUserGetWatchlistRequest) (*UserGetWatchlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetWatchlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserGetWatchlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/watchlist"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOrderCancelRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	orderId string
}

func (r ApiUserOrderCancelRequest) Execute() (*UserOrderDecreaseResponse, *http.Response, error) {
	return r.ApiService.UserOrderCancelExecute(r)
}

/*
UserOrderCancel UserOrderCancel

End-point for canceling orders.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).
The value for the order_id should match the id field of the order you want to decrease.
Commonly delete end-points return 204 status with no body content on success.
But we can't completely delete the order, as it may be partially filled already.
So what the delete end-point does is just reducing the order completely zeroing the remaining resting contracts on it.
The zeroed order is returned on the response payload, as a form of validation for the client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @param orderId This order_id should be filled with the id of the order to be decrease
 @return ApiUserOrderCancelRequest
*/
func (a *UserApiService) UserOrderCancel(ctx context.Context, userId string, orderId string) ApiUserOrderCancelRequest {
	return ApiUserOrderCancelRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return UserOrderDecreaseResponse
func (a *UserApiService) UserOrderCancelExecute(r ApiUserOrderCancelRequest) (*UserOrderDecreaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserOrderDecreaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserOrderCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOrderCreateRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	userOrderCreateRequest *UserOrderCreateRequest
}

// Order create input data
func (r ApiUserOrderCreateRequest) UserOrderCreateRequest(userOrderCreateRequest UserOrderCreateRequest) ApiUserOrderCreateRequest {
	r.userOrderCreateRequest = &userOrderCreateRequest
	return r
}

func (r ApiUserOrderCreateRequest) Execute() (*UserOrderCreateResponse, *http.Response, error) {
	return r.ApiService.UserOrderCreateExecute(r)
}

/*
UserOrderCreate UserOrderCreate

End-point for submitting orders in a market.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserOrderCreateRequest
*/
func (a *UserApiService) UserOrderCreate(ctx context.Context, userId string) ApiUserOrderCreateRequest {
	return ApiUserOrderCreateRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserOrderCreateResponse
func (a *UserApiService) UserOrderCreateExecute(r ApiUserOrderCreateRequest) (*UserOrderCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserOrderCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserOrderCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userOrderCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOrderDecreaseRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	orderId string
	userOrderDecreaseRequest *UserOrderDecreaseRequest
}

// Order data
func (r ApiUserOrderDecreaseRequest) UserOrderDecreaseRequest(userOrderDecreaseRequest UserOrderDecreaseRequest) ApiUserOrderDecreaseRequest {
	r.userOrderDecreaseRequest = &userOrderDecreaseRequest
	return r
}

func (r ApiUserOrderDecreaseRequest) Execute() (*UserOrderDecreaseResponse, *http.Response, error) {
	return r.ApiService.UserOrderDecreaseExecute(r)
}

/*
UserOrderDecrease UserOrderDecrease

End-point for decreasing the number of contracts on orders. This is the only kind of edit we support on orders.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the order_id should match the id field of the order you want to decrease.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @param orderId This order_id should be filled with the id of the order to be decrease
 @return ApiUserOrderDecreaseRequest
*/
func (a *UserApiService) UserOrderDecrease(ctx context.Context, userId string, orderId string) ApiUserOrderDecreaseRequest {
	return ApiUserOrderDecreaseRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return UserOrderDecreaseResponse
func (a *UserApiService) UserOrderDecreaseExecute(r ApiUserOrderDecreaseRequest) (*UserOrderDecreaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserOrderDecreaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserOrderDecrease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/orders/{order_id}/decrease"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterToString(r.orderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userOrderDecreaseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOrdersGetRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	marketId *string
	isYes *bool
	minPrice *int64
	maxPrice *int64
	minPlaceCount *int32
	maxPlaceCount *int32
	minInitialCount *int32
	maxInitialCount *int32
	minRemainingCount *int32
	maxRemainingCount *int32
	minDate *time.Time
	maxDate *time.Time
	getQueuePosition *bool
	status *string
	pageSize *int64
	pageNumber *int64
}

// Restricts the response to orders in a single market
func (r ApiUserOrdersGetRequest) MarketId(marketId string) ApiUserOrdersGetRequest {
	r.marketId = &marketId
	return r
}

// Restricts the response to orders in a single direction (yes or no)
func (r ApiUserOrdersGetRequest) IsYes(isYes bool) ApiUserOrdersGetRequest {
	r.isYes = &isYes
	return r
}

// Restricts the response to orders within a minimum price
func (r ApiUserOrdersGetRequest) MinPrice(minPrice int64) ApiUserOrdersGetRequest {
	r.minPrice = &minPrice
	return r
}

// Restricts the response to orders within a maximum price
func (r ApiUserOrdersGetRequest) MaxPrice(maxPrice int64) ApiUserOrdersGetRequest {
	r.maxPrice = &maxPrice
	return r
}

// Restricts the response to orders within a minimum place count
func (r ApiUserOrdersGetRequest) MinPlaceCount(minPlaceCount int32) ApiUserOrdersGetRequest {
	r.minPlaceCount = &minPlaceCount
	return r
}

// Restricts the response to orders within a maximum place count
func (r ApiUserOrdersGetRequest) MaxPlaceCount(maxPlaceCount int32) ApiUserOrdersGetRequest {
	r.maxPlaceCount = &maxPlaceCount
	return r
}

// Restricts the response to orders within a minimum initial count
func (r ApiUserOrdersGetRequest) MinInitialCount(minInitialCount int32) ApiUserOrdersGetRequest {
	r.minInitialCount = &minInitialCount
	return r
}

// Restricts the response to orders within a maximum initial count
func (r ApiUserOrdersGetRequest) MaxInitialCount(maxInitialCount int32) ApiUserOrdersGetRequest {
	r.maxInitialCount = &maxInitialCount
	return r
}

// Restricts the response to orders within a minimum remaining resting contracts count
func (r ApiUserOrdersGetRequest) MinRemainingCount(minRemainingCount int32) ApiUserOrdersGetRequest {
	r.minRemainingCount = &minRemainingCount
	return r
}

// Restricts the response to orders within a maximum remaining resting contracts count
func (r ApiUserOrdersGetRequest) MaxRemainingCount(maxRemainingCount int32) ApiUserOrdersGetRequest {
	r.maxRemainingCount = &maxRemainingCount
	return r
}

// Restricts the response to orders after a timestamp
func (r ApiUserOrdersGetRequest) MinDate(minDate time.Time) ApiUserOrdersGetRequest {
	r.minDate = &minDate
	return r
}

// Restricts the response to orders before a timestamp
func (r ApiUserOrdersGetRequest) MaxDate(maxDate time.Time) ApiUserOrdersGetRequest {
	r.maxDate = &maxDate
	return r
}

// If true, gets the queue placement for every resting order returned
func (r ApiUserOrdersGetRequest) GetQueuePosition(getQueuePosition bool) ApiUserOrdersGetRequest {
	r.getQueuePosition = &getQueuePosition
	return r
}

// Restricts the response to orders that have a certain status: resting, canceled, or executed
func (r ApiUserOrdersGetRequest) Status(status string) ApiUserOrdersGetRequest {
	r.status = &status
	return r
}

// Parameter to specify the number of results per page
func (r ApiUserOrdersGetRequest) PageSize(pageSize int64) ApiUserOrdersGetRequest {
	r.pageSize = &pageSize
	return r
}

// Parameter to specify which page of the results should be retrieved
func (r ApiUserOrdersGetRequest) PageNumber(pageNumber int64) ApiUserOrdersGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiUserOrdersGetRequest) Execute() (*UserOrdersGetResponse, *http.Response, error) {
	return r.ApiService.UserOrdersGetExecute(r)
}

/*
UserOrdersGet UserOrdersGet

End-point for getting all orders for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserOrdersGetRequest
*/
func (a *UserApiService) UserOrdersGet(ctx context.Context, userId string) ApiUserOrdersGetRequest {
	return ApiUserOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserOrdersGetResponse
func (a *UserApiService) UserOrdersGetExecute(r ApiUserOrdersGetRequest) (*UserOrdersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserOrdersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.marketId != nil {
		localVarQueryParams.Add("market_id", parameterToString(*r.marketId, ""))
	}
	if r.isYes != nil {
		localVarQueryParams.Add("is_yes", parameterToString(*r.isYes, ""))
	}
	if r.minPrice != nil {
		localVarQueryParams.Add("min_price", parameterToString(*r.minPrice, ""))
	}
	if r.maxPrice != nil {
		localVarQueryParams.Add("max_price", parameterToString(*r.maxPrice, ""))
	}
	if r.minPlaceCount != nil {
		localVarQueryParams.Add("min_place_count", parameterToString(*r.minPlaceCount, ""))
	}
	if r.maxPlaceCount != nil {
		localVarQueryParams.Add("max_place_count", parameterToString(*r.maxPlaceCount, ""))
	}
	if r.minInitialCount != nil {
		localVarQueryParams.Add("min_initial_count", parameterToString(*r.minInitialCount, ""))
	}
	if r.maxInitialCount != nil {
		localVarQueryParams.Add("max_initial_count", parameterToString(*r.maxInitialCount, ""))
	}
	if r.minRemainingCount != nil {
		localVarQueryParams.Add("min_remaining_count", parameterToString(*r.minRemainingCount, ""))
	}
	if r.maxRemainingCount != nil {
		localVarQueryParams.Add("max_remaining_count", parameterToString(*r.maxRemainingCount, ""))
	}
	if r.minDate != nil {
		localVarQueryParams.Add("min_date", parameterToString(*r.minDate, ""))
	}
	if r.maxDate != nil {
		localVarQueryParams.Add("max_date", parameterToString(*r.maxDate, ""))
	}
	if r.getQueuePosition != nil {
		localVarQueryParams.Add("get_queue_position", parameterToString(*r.getQueuePosition, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("page_number", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserRemoveFavoritedSeriesRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	seriesTicker string
}

func (r ApiUserRemoveFavoritedSeriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRemoveFavoritedSeriesExecute(r)
}

/*
UserRemoveFavoritedSeries UserRemoveFavoritedSeries

End-point for removing a series from the logged in user's favorites.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the series_ticker path parameter should match the ticker value of the series to be removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId user_id should be filled with your user_id provided on log_in
 @param seriesTicker series_ticker should be filled with the ticker of the series to be removed from the list
 @return ApiUserRemoveFavoritedSeriesRequest
*/
func (a *UserApiService) UserRemoveFavoritedSeries(ctx context.Context, userId string, seriesTicker string) ApiUserRemoveFavoritedSeriesRequest {
	return ApiUserRemoveFavoritedSeriesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		seriesTicker: seriesTicker,
	}
}

// Execute executes the request
func (a *UserApiService) UserRemoveFavoritedSeriesExecute(r ApiUserRemoveFavoritedSeriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserRemoveFavoritedSeries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/favorited_series/{series_ticker}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_ticker"+"}", url.PathEscape(parameterToString(r.seriesTicker, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserRemoveWatchlistRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	marketId string
}

func (r ApiUserRemoveWatchlistRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserRemoveWatchlistExecute(r)
}

/*
UserRemoveWatchlist UserRemoveWatchlist

End-point for removing a market from the logged in user's watchlist.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the market_id path parameter should match the id value of the market to be added.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @param marketId Should be filled with the id of the target market
 @return ApiUserRemoveWatchlistRequest
*/
func (a *UserApiService) UserRemoveWatchlist(ctx context.Context, userId string, marketId string) ApiUserRemoveWatchlistRequest {
	return ApiUserRemoveWatchlistRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		marketId: marketId,
	}
}

// Execute executes the request
func (a *UserApiService) UserRemoveWatchlistExecute(r ApiUserRemoveWatchlistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserRemoveWatchlist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/watchlist/{market_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"market_id"+"}", url.PathEscape(parameterToString(r.marketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserTradesGetRequest struct {
	ctx context.Context
	ApiService UserApi
	userId string
	marketId *string
	orderId *string
	minPrice *int64
	maxPrice *int64
	minCount *int32
	maxCount *int32
	minDate *time.Time
	maxDate *time.Time
	pageSize *int64
	pageNumber *int64
}

// Restricts the response to trades in a specific market.
func (r ApiUserTradesGetRequest) MarketId(marketId string) ApiUserTradesGetRequest {
	r.marketId = &marketId
	return r
}

// Restricts the response to trades related to a specific order.
func (r ApiUserTradesGetRequest) OrderId(orderId string) ApiUserTradesGetRequest {
	r.orderId = &orderId
	return r
}

// Restricts the response to trades within a minimum price.
func (r ApiUserTradesGetRequest) MinPrice(minPrice int64) ApiUserTradesGetRequest {
	r.minPrice = &minPrice
	return r
}

// Restricts the response to trades within a maximum price.
func (r ApiUserTradesGetRequest) MaxPrice(maxPrice int64) ApiUserTradesGetRequest {
	r.maxPrice = &maxPrice
	return r
}

// Restricts the response to trades within a minimum contracts count.
func (r ApiUserTradesGetRequest) MinCount(minCount int32) ApiUserTradesGetRequest {
	r.minCount = &minCount
	return r
}

// Restricts the response to trades within a maximum contracts count.
func (r ApiUserTradesGetRequest) MaxCount(maxCount int32) ApiUserTradesGetRequest {
	r.maxCount = &maxCount
	return r
}

// Restricts the response to trades after a timestamp.
func (r ApiUserTradesGetRequest) MinDate(minDate time.Time) ApiUserTradesGetRequest {
	r.minDate = &minDate
	return r
}

// Restricts the response to trades before a timestamp.
func (r ApiUserTradesGetRequest) MaxDate(maxDate time.Time) ApiUserTradesGetRequest {
	r.maxDate = &maxDate
	return r
}

// Parameter to specify the number of results per page
func (r ApiUserTradesGetRequest) PageSize(pageSize int64) ApiUserTradesGetRequest {
	r.pageSize = &pageSize
	return r
}

// Parameter to specify which page of the results should be retrieved
func (r ApiUserTradesGetRequest) PageNumber(pageNumber int64) ApiUserTradesGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiUserTradesGetRequest) Execute() (*UserTradesGetResponse, *http.Response, error) {
	return r.ApiService.UserTradesGetExecute(r)
}

/*
UserTradesGet UserTradesGet

End-point for getting all trades for the logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserTradesGetRequest
*/
func (a *UserApiService) UserTradesGet(ctx context.Context, userId string) ApiUserTradesGetRequest {
	return ApiUserTradesGetRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserTradesGetResponse
func (a *UserApiService) UserTradesGetExecute(r ApiUserTradesGetRequest) (*UserTradesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserTradesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.UserTradesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/trades"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.marketId != nil {
		localVarQueryParams.Add("market_id", parameterToString(*r.marketId, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("order_id", parameterToString(*r.orderId, ""))
	}
	if r.minPrice != nil {
		localVarQueryParams.Add("MinPrice", parameterToString(*r.minPrice, ""))
	}
	if r.maxPrice != nil {
		localVarQueryParams.Add("MaxPrice", parameterToString(*r.maxPrice, ""))
	}
	if r.minCount != nil {
		localVarQueryParams.Add("MinCount", parameterToString(*r.minCount, ""))
	}
	if r.maxCount != nil {
		localVarQueryParams.Add("max_count", parameterToString(*r.maxCount, ""))
	}
	if r.minDate != nil {
		localVarQueryParams.Add("min_date", parameterToString(*r.minDate, ""))
	}
	if r.maxDate != nil {
		localVarQueryParams.Add("max_date", parameterToString(*r.maxDate, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("page_number", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
