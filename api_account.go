/*
Kalshi API.

This documentation describes Kalshi's REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kalshiAPI

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type AccountApi interface {

	/*
	ChangeSubscription ChangeSubscription

	End-point for changing e-mail subscription mode for the current user.

This end-point is very useful for users that have a large volume of orders and don't want to be email notified whenever an order is submitted / edited / canceled or matches.

This is specially useful for Market Makers.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Should be filled with your user_id provided on log_in
	@return ApiChangeSubscriptionRequest
	*/
	ChangeSubscription(ctx context.Context, userId string) ApiChangeSubscriptionRequest

	// ChangeSubscriptionExecute executes the request
	//  @return ChangeSubscriptionResponse
	ChangeSubscriptionExecute(r ApiChangeSubscriptionRequest) (*ChangeSubscriptionResponse, *http.Response, error)

	/*
	GetNotificationPreferences GetNotificationPreferences

	End-point for getting e-mail subscription mode for the current user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiGetNotificationPreferencesRequest
	*/
	GetNotificationPreferences(ctx context.Context, userId string) ApiGetNotificationPreferencesRequest

	// GetNotificationPreferencesExecute executes the request
	//  @return GetNotificationPreferencesResponse
	GetNotificationPreferencesExecute(r ApiGetNotificationPreferencesRequest) (*GetNotificationPreferencesResponse, *http.Response, error)

	/*
	NotificationMarkRead NotificationMarkRead

	End-point for marking a notification as read.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the notification_id path parameter should match the notification_id value of the notification to be marked as read.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId user_id should be filled with your user_id provided on log_in
	@param notificationId notification_id should be filled with the id of the notification to be mark as read
	@return ApiNotificationMarkReadRequest
	*/
	NotificationMarkRead(ctx context.Context, userId string, notificationId string) ApiNotificationMarkReadRequest

	// NotificationMarkReadExecute executes the request
	NotificationMarkReadExecute(r ApiNotificationMarkReadRequest) (*http.Response, error)

	/*
	UserGetAccountHistory UserGetAccountHistory

	End-point for getting the logged in user's important past actions and events related to the user's positions.

This contains entries for user's explicit actions but also for market events.

There will be entries for:

submitting, editing / canceling orders
requesting deposits and withdrawals
trade execution (order matching)
market settlements on markets where you have a position

The value for the user_id path parameter should match the user_id value returned on the response for the
last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserGetAccountHistoryRequest
	*/
	UserGetAccountHistory(ctx context.Context, userId string) ApiUserGetAccountHistoryRequest

	// UserGetAccountHistoryExecute executes the request
	//  @return UserGetAccountHistoryResponse
	UserGetAccountHistoryExecute(r ApiUserGetAccountHistoryRequest) (*UserGetAccountHistoryResponse, *http.Response, error)

	/*
	UserGetNotifications UserGetNotifications

	End-point for getting notifications for the current logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserGetNotificationsRequest
	*/
	UserGetNotifications(ctx context.Context, userId string) ApiUserGetNotificationsRequest

	// UserGetNotificationsExecute executes the request
	//  @return UserGetNotificationsResponse
	UserGetNotificationsExecute(r ApiUserGetNotificationsRequest) (*UserGetNotificationsResponse, *http.Response, error)

	/*
	UserGetProfitsAndLosses UserGetProfitsAndLosses

	This end point returns profits, losses, and market transactions between two dates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId This parameter should be filled with your user_id provided on log_in
	@return ApiUserGetProfitsAndLossesRequest
	*/
	UserGetProfitsAndLosses(ctx context.Context, userId string) ApiUserGetProfitsAndLossesRequest

	// UserGetProfitsAndLossesExecute executes the request
	//  @return UserGetProfitsAndLossesResponse
	UserGetProfitsAndLossesExecute(r ApiUserGetProfitsAndLossesRequest) (*UserGetProfitsAndLossesResponse, *http.Response, error)
}

// AccountApiService AccountApi service
type AccountApiService service

type ApiChangeSubscriptionRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
	changeSubscriptionRequest *ChangeSubscriptionRequest
}

// Change subscription data
func (r ApiChangeSubscriptionRequest) ChangeSubscriptionRequest(changeSubscriptionRequest ChangeSubscriptionRequest) ApiChangeSubscriptionRequest {
	r.changeSubscriptionRequest = &changeSubscriptionRequest
	return r
}

func (r ApiChangeSubscriptionRequest) Execute() (*ChangeSubscriptionResponse, *http.Response, error) {
	return r.ApiService.ChangeSubscriptionExecute(r)
}

/*
ChangeSubscription ChangeSubscription

End-point for changing e-mail subscription mode for the current user.

This end-point is very useful for users that have a large volume of orders and don't want to be email notified whenever an order is submitted / edited / canceled or matches.

This is specially useful for Market Makers.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Should be filled with your user_id provided on log_in
 @return ApiChangeSubscriptionRequest
*/
func (a *AccountApiService) ChangeSubscription(ctx context.Context, userId string) ApiChangeSubscriptionRequest {
	return ApiChangeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return ChangeSubscriptionResponse
func (a *AccountApiService) ChangeSubscriptionExecute(r ApiChangeSubscriptionRequest) (*ChangeSubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeSubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.ChangeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/subscribe"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changeSubscriptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationPreferencesRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
}

func (r ApiGetNotificationPreferencesRequest) Execute() (*GetNotificationPreferencesResponse, *http.Response, error) {
	return r.ApiService.GetNotificationPreferencesExecute(r)
}

/*
GetNotificationPreferences GetNotificationPreferences

End-point for getting e-mail subscription mode for the current user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiGetNotificationPreferencesRequest
*/
func (a *AccountApiService) GetNotificationPreferences(ctx context.Context, userId string) ApiGetNotificationPreferencesRequest {
	return ApiGetNotificationPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return GetNotificationPreferencesResponse
func (a *AccountApiService) GetNotificationPreferencesExecute(r ApiGetNotificationPreferencesRequest) (*GetNotificationPreferencesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNotificationPreferencesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.GetNotificationPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/notifications/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationMarkReadRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
	notificationId string
}

func (r ApiNotificationMarkReadRequest) Execute() (*http.Response, error) {
	return r.ApiService.NotificationMarkReadExecute(r)
}

/*
NotificationMarkRead NotificationMarkRead

End-point for marking a notification as read.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

The value for the notification_id path parameter should match the notification_id value of the notification to be marked as read.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId user_id should be filled with your user_id provided on log_in
 @param notificationId notification_id should be filled with the id of the notification to be mark as read
 @return ApiNotificationMarkReadRequest
*/
func (a *AccountApiService) NotificationMarkRead(ctx context.Context, userId string, notificationId string) ApiNotificationMarkReadRequest {
	return ApiNotificationMarkReadRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		notificationId: notificationId,
	}
}

// Execute executes the request
func (a *AccountApiService) NotificationMarkReadExecute(r ApiNotificationMarkReadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.NotificationMarkRead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/notifications/{notification_id}/read"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"notification_id"+"}", url.PathEscape(parameterToString(r.notificationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserGetAccountHistoryRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
	deposits *bool
	withdrawals *bool
	orders *bool
	settlements *bool
	trades *bool
	credits *bool
	limit *int64
	pageSize *int64
	pageNumber *int64
}

// If true the response should include deposit entries
func (r ApiUserGetAccountHistoryRequest) Deposits(deposits bool) ApiUserGetAccountHistoryRequest {
	r.deposits = &deposits
	return r
}

// If true the response should include withdrawal entries
func (r ApiUserGetAccountHistoryRequest) Withdrawals(withdrawals bool) ApiUserGetAccountHistoryRequest {
	r.withdrawals = &withdrawals
	return r
}

// If true the response should include order entries
func (r ApiUserGetAccountHistoryRequest) Orders(orders bool) ApiUserGetAccountHistoryRequest {
	r.orders = &orders
	return r
}

// If true the response should include settlement entries
func (r ApiUserGetAccountHistoryRequest) Settlements(settlements bool) ApiUserGetAccountHistoryRequest {
	r.settlements = &settlements
	return r
}

// If true the response should include trade entries
func (r ApiUserGetAccountHistoryRequest) Trades(trades bool) ApiUserGetAccountHistoryRequest {
	r.trades = &trades
	return r
}

// If true the response should include credit entries
func (r ApiUserGetAccountHistoryRequest) Credits(credits bool) ApiUserGetAccountHistoryRequest {
	r.credits = &credits
	return r
}

// Restricts the response to a return the first \&quot;limit\&quot; amount of acct history items. Note if you specify a limit, you cannot specify a PageSize or PageNumber
func (r ApiUserGetAccountHistoryRequest) Limit(limit int64) ApiUserGetAccountHistoryRequest {
	r.limit = &limit
	return r
}

// Parameter to specify the number of results per page.
func (r ApiUserGetAccountHistoryRequest) PageSize(pageSize int64) ApiUserGetAccountHistoryRequest {
	r.pageSize = &pageSize
	return r
}

// Parameter to specify which page of the results should be retrieved
func (r ApiUserGetAccountHistoryRequest) PageNumber(pageNumber int64) ApiUserGetAccountHistoryRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiUserGetAccountHistoryRequest) Execute() (*UserGetAccountHistoryResponse, *http.Response, error) {
	return r.ApiService.UserGetAccountHistoryExecute(r)
}

/*
UserGetAccountHistory UserGetAccountHistory

End-point for getting the logged in user's important past actions and events related to the user's positions.

This contains entries for user's explicit actions but also for market events.

There will be entries for:

submitting, editing / canceling orders
requesting deposits and withdrawals
trade execution (order matching)
market settlements on markets where you have a position

The value for the user_id path parameter should match the user_id value returned on the response for the
last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserGetAccountHistoryRequest
*/
func (a *AccountApiService) UserGetAccountHistory(ctx context.Context, userId string) ApiUserGetAccountHistoryRequest {
	return ApiUserGetAccountHistoryRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetAccountHistoryResponse
func (a *AccountApiService) UserGetAccountHistoryExecute(r ApiUserGetAccountHistoryRequest) (*UserGetAccountHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetAccountHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.UserGetAccountHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/account/history"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deposits != nil {
		localVarQueryParams.Add("Deposits", parameterToString(*r.deposits, ""))
	}
	if r.withdrawals != nil {
		localVarQueryParams.Add("Withdrawals", parameterToString(*r.withdrawals, ""))
	}
	if r.orders != nil {
		localVarQueryParams.Add("Orders", parameterToString(*r.orders, ""))
	}
	if r.settlements != nil {
		localVarQueryParams.Add("Settlements", parameterToString(*r.settlements, ""))
	}
	if r.trades != nil {
		localVarQueryParams.Add("Trades", parameterToString(*r.trades, ""))
	}
	if r.credits != nil {
		localVarQueryParams.Add("Credits", parameterToString(*r.credits, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("Limit", parameterToString(*r.limit, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("page_number", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetNotificationsRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
	pageSize *int64
	pageNumber *int64
}

// Number of results per page
func (r ApiUserGetNotificationsRequest) PageSize(pageSize int64) ApiUserGetNotificationsRequest {
	r.pageSize = &pageSize
	return r
}

// Page of the results
func (r ApiUserGetNotificationsRequest) PageNumber(pageNumber int64) ApiUserGetNotificationsRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiUserGetNotificationsRequest) Execute() (*UserGetNotificationsResponse, *http.Response, error) {
	return r.ApiService.UserGetNotificationsExecute(r)
}

/*
UserGetNotifications UserGetNotifications

End-point for getting notifications for the current logged in user.

The value for the user_id path parameter should match the user_id value returned on the response for the last login request (POST /log_in).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserGetNotificationsRequest
*/
func (a *AccountApiService) UserGetNotifications(ctx context.Context, userId string) ApiUserGetNotificationsRequest {
	return ApiUserGetNotificationsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetNotificationsResponse
func (a *AccountApiService) UserGetNotificationsExecute(r ApiUserGetNotificationsRequest) (*UserGetNotificationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetNotificationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.UserGetNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/notifications"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pageSize == nil {
		return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
	}
	if *r.pageSize > 50 {
		return localVarReturnValue, nil, reportError("pageSize must be less than 50")
	}
	if r.pageNumber == nil {
		return localVarReturnValue, nil, reportError("pageNumber is required and must be specified")
	}

	localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	localVarQueryParams.Add("page_number", parameterToString(*r.pageNumber, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetProfitsAndLossesRequest struct {
	ctx context.Context
	ApiService AccountApi
	userId string
	startTs *int64
	endTs *int64
}

// Start time of pnl period, represented as the number of seconds since Unix epoch
func (r ApiUserGetProfitsAndLossesRequest) StartTs(startTs int64) ApiUserGetProfitsAndLossesRequest {
	r.startTs = &startTs
	return r
}

// End time of pnl period, represented as the number of seconds since Unix epoch
func (r ApiUserGetProfitsAndLossesRequest) EndTs(endTs int64) ApiUserGetProfitsAndLossesRequest {
	r.endTs = &endTs
	return r
}

func (r ApiUserGetProfitsAndLossesRequest) Execute() (*UserGetProfitsAndLossesResponse, *http.Response, error) {
	return r.ApiService.UserGetProfitsAndLossesExecute(r)
}

/*
UserGetProfitsAndLosses UserGetProfitsAndLosses

This end point returns profits, losses, and market transactions between two dates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId This parameter should be filled with your user_id provided on log_in
 @return ApiUserGetProfitsAndLossesRequest
*/
func (a *AccountApiService) UserGetProfitsAndLosses(ctx context.Context, userId string) ApiUserGetProfitsAndLossesRequest {
	return ApiUserGetProfitsAndLossesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserGetProfitsAndLossesResponse
func (a *AccountApiService) UserGetProfitsAndLossesExecute(r ApiUserGetProfitsAndLossesRequest) (*UserGetProfitsAndLossesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGetProfitsAndLossesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.UserGetProfitsAndLosses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/account/pnl"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTs != nil {
		localVarQueryParams.Add("StartTs", parameterToString(*r.startTs, ""))
	}
	if r.endTs != nil {
		localVarQueryParams.Add("EndTs", parameterToString(*r.endTs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
